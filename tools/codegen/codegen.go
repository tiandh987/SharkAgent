package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// 生成的 Markdown 文档前缀
var errCodeDocPrefix = `# 错误码

！！SharkAgent 系统错误码列表，由 {{.}}codegen -type=int -doc{{.}} 命令生成，不要对此文件做任何更改。

## 功能说明

如果返回结果中存在 {{.}}code{{.}} 字段，则表示调用 API 接口失败。例如：

{{.}}{{.}}{{.}}json
{
  "code": 100101,
  "message": "Database error"
}
{{.}}{{.}}{{.}}

上述返回中 {{.}}code{{.}} 表示错误码，{{.}}message{{.}} 表示该错误的具体信息。每个错误同时也对应一个 HTTP 状态码，比如上述错误码对应了 HTTP 状态码 500(Internal Server Error)。

## 错误码列表

IAM 系统支持的错误码列表如下：

| Identifier | Code | HTTP Code | Description |
| ---------- | ---- | --------- | ----------- |
`
var (
	// 逗号分隔的类型名称列表; 必须设置
	typeNames  = flag.String("type", "", "comma-separated list of type names; must be set")

	// 输出文件名; 默认为 srcdir/<type>_string.go
	output     = flag.String("output", "", "output file name; default srcdir/<type>_string.go")

	// 从生成的常量名称中去除 "prefix"
	trimprefix = flag.String("trimprefix", "", "trim the `prefix` from the generated constant names")

	// 逗号分隔的应用构建标签列表
	buildTags  = flag.String("tags", "", "comma-separated list of build tags to apply")

	// 如果为 true，则仅生成 markdown 格式的错误代码文档
	doc        = flag.Bool("doc", false, "if true only generate error code documentation in markdown format")
)

func Usage() {
	fmt.Fprint(os.Stderr, "Usage of codegen:\n")
	fmt.Fprintf(os.Stderr, "\tcodegen [flags] -type T [directory]\n")
	fmt.Fprintf(os.Stderr, "\tcodegen [flags] -type T files... # Must be a single package\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

//	$ ./codegen.exe -h
//	Usage of codegen:
// 		codegen [flags] -type T [directory]
//		codegen [flags] -type T files... # Must be a single package
//	Flags:
//		-doc
//			if true only generate error code documentation in markdown format
//		-output string
//			output file name; default srcdir/<type>_string.go
//		-tags string
//			comma-separated list of build tags to apply
//		-trimprefix prefix
//			trim the prefix from the generated constant names
//		-type string
//			comma-separated list of type names; must be set


func main() {
	// 设置标准 logger 的输出标志。
	log.SetFlags(0)
	// 设置标准 logger 的输出前缀。
	log.SetPrefix("codegen: ")

	flag.Usage= Usage
	// Parse 解析来自 os.Args[1:] 的命令行标志。
	// 必须在定义所有标志之后，且在程序访问标志之前 调用。
	flag.Parse()

	// 参数校验
	if len(*typeNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	types := strings.Split(*typeNames, ",")

	// 参数校验
	var tags []string
	if len(*buildTags) > 0 {
		tags = strings.Split(*buildTags, ",")
	}

	// We accept either one directory or a list of files. Which do we have?
	// flag.Args() 返回 non-flag 命令行参数。
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	// Parse the package once.
	var dir string
	g := Generator{
		trimPrefix: *trimprefix,
	}

	if len(args) == 1 && isDirectory(args[0]) {
		// 如果 non-flag 参数为 1，且是一个目录
		dir = args[0]
	} else {
		if len(tags) != 0 {
			// -tags 选项只适用于目录
			log.Fatal("-tags option applies only to directories, not when files are specified")
		}
		dir = filepath.Dir(args[0])
	}
	g.parsePackage(args, tags)

	// -doc 为 false
	if !*doc {
		// Print the header and package clause.
		g.Printf("// Copyright 2022 SharkAgent <xxx@163.com>. All rights reserved.\n")
		g.Printf("// Use of this source code is governed by a MIT style\n")
		g.Printf("// license that can be found in the LICENSE file.\n")
		g.Printf("\n")
		g.Printf("// Code generated by \"codegen %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
		g.Printf("\n")
		g.Printf("package %s", g.pkg.name)
		g.Printf("\n")
	}

	// Run generate for each type.
	var src []byte
	for _, typeName := range types {
		if *doc {
			g.generateDocs(typeName)
			src = g.buf.Bytes()
		} else {
			g.generate(typeName)
			// Format the output.
			src = g.format()
		}
	}

	// Write to file.
	outputName := *output
	if outputName == "" {
		absDir, _ := filepath.Abs(dir)
		baseName := fmt.Sprintf("%s_generated.go", strings.ReplaceAll(filepath.Base(absDir), "-", "_"))
		if len(flag.Args()) == 1 {
			baseName = fmt.Sprintf(
				"%s_generated.go",
				strings.ReplaceAll(filepath.Base(strings.TrimSuffix(flag.Args()[0], ".go")), "-", "_"),
			)
		}

		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}
	err := ioutil.WriteFile(outputName, src, 0o600)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}

	return info.IsDir()
}